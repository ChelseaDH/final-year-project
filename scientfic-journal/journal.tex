\documentclass[11pt,a4paper,british]{bhamarticle}
\usepackage[margin=7.5em]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{babel}
\usepackage{csquotes}
\usepackage{isodate}

\usepackage[
    backend=biber,
    sorting=none,
    citestyle=numeric-comp
]{biblatex}
\usepackage[hidelinks]{hyperref}
\addbibresource{references.bib}

% Fix paragraph spacing and use of noindent
\usepackage[parfill]{parskip}
\usepackage{titlesec}
\setlength{\parskip}{1\smallskipamount plus \smallskipamount minus \smallskipamount}
\titlespacing{\section}{0pt}{1.4\parskip}{0.2\parskip}
\titlespacing{\subsection}{0pt}{1.4\parskip}{0.2\parskip}
\titlespacing{\subsubsection}{0pt}{1.4\parskip}{0.2\parskip}

\title{netd: A TCP/IP networking stack implementation in userland}
\author{Joe Groocock}
\supervisor{Dr Ian Batten}
\department{Computer Science}
\degree{Computer Science MSci}
\gyear{2017}

\begin{document}
\pagenumbering{gobble}

\maketitle

\begin{abstract}
\end{abstract}

\tableofcontents
\newpage

\pagenumbering{arabic}

\section{Introduction}

\pagebreak
\section{Literature Review}
% Difficult to find papers about TCP implementations as there aren't many
% RFC675 overview
When TCP was originally proposed in December 1974 by \citeauthor{rfc675} in RFC 675~\cite{rfc675} that defined flow diagrams and implementation suggestions but did not provide specific pseudo-code routines that could be implemented directly. At that time TCP was young and naive due to having little exposure to real-world use cases. Furthermore the limitations of the technology of the era were apparent in the original design given the scope and proposed use of the protocol, compared to the significantly higher speed demands in 2017.

% RFC793 overview & level-ip implementation to the spec
RFC 793 followed a some years later and provided a more specific breakdown, that can be directly translated and implemented in code, of each event within the protocol and an appropriate procedure to handle it~\cite[Page~54-77]{rfc793}. \citeauthor{rfc793} who published the specification, now recognised as an official internet standard, define TCP as `a connection-oriented, end-to-end reliable protocol' as it is now widely known. The document provides a well-defined list of requirements for the protocol to run as well as a multitude of provisions for successful operation within the promises.
Many implementations of the TCP/IP stack, including but not limited to `Level-IP' by \citeauthor{levelip-spec}, follow this specification~\cite[\texttt{src/tcp\_input.c} line~262]{levelip-spec} very closely which in theory produces a TCP that should interwork correctly, as per the specification, with any other correctly implemented TCP. % chktex 13

% lwIP goals
Not all TCP/IP stacks are created equal; there are numerous incentives for developing alternate implementations, for example `lwIP' from \citeauthor{lwip}~(\citeyear{lwip}) built `to reduce memory usage and code size, making lwIP suitable for use in small clients with very limited resources such as embedded systems'. There are many inefficiencies in `standard' networking stacks like those included in popular operating systems such as Linux, BSD, macOS and Windows, to name a few, especially regarding memory usage. These protocols make the assumption that the physical system has considerable amounts of memory available for receiving, processing and duplicating network data both in the kernel and in user applications. \citeauthor{lwip} makes the opposite assumption and as a result produced a system where minimal replication of data and little wasted memory allocation occurs. Using dynamically sized packet buffers \texttt{pbufs}, \citeauthor{lwip} made efficient use of RAM, ROM and pooled memory to address network data without requiring it to be copied to a local storage space before being actioned. Through many small optimisations like these, lwIP was, and still is, a very effective network stack usable on even the most restricted hardware which in the growing interconnected embedded device market is invaluable.
% TODO: Maybe talk about uIP here, if I have space/time/the will to live

% mTCP goals
Conversely some alternate implementations exist for quite the opposite reasons such as `mTCP', \citeauthor{jeong2014mtcp} constructed as `a highly scalable user-level TCP stack for multicore systems'. \citeauthor{jeong2014mtcp} intended mTCP to outperform competing solutions in packet throughput and data volume. According to their claims, mTCP can surpass Linux by a factor of 25 in `small message transactions' and also boosting regular performance of popular applications between 33\% and 320\%. Such performance numbers are impressive, especially considering the widespread use of Linux for commercial applications and hosting, which begs the question: ``Why is it significantly faster than the default Linux implementation and why hasn't Linux caught up yet?''

Many of the improvements suggested in this paper by \citeauthor{jeong2014mtcp} are very intelligent applications of high speed network adapters and multicore processor systems such as servers. Any TCP network stack that is to be run in these kinds of scenarios should consider these optimisations for improved performance. It is likely that many of the proposed enhancements would also benefit low-power single CPU systems too with most likely reduced latency and reduced memory usage.

% Demultiplexing TCP in the kernel
\citeauthor{braun:inria-00074040} designed a modified BSD TCP/IP stack where the IP layer resides in the kernel and TCP is split in two between kernel and userspace into TCPU and TCPK respectively. TCP processing is moved mostly into the user region, residing as local code in the calling process. The only exception to this is the `demultiplexing' step, TCPK, where TCP frames are routed to the correct user program based on the ports and addresses from the IP layer packet, providing security for the receiving process.

% Demultiplexing in userspace, or not
\citeauthor{braun:inria-00074040} theorise that a potential alternative method for demultiplexing packets would be to pass all incoming traffic directly into a userspace daemon for processing removing the requirement on kernel modifications but closes by concluding that the concept is impractical and inefficient compared with the alternative solution (above) as packets are processed by two userspace applications, causing more context switches passing data from the daemon to the receiving processes~\cite[2.1]{braun:inria-00074040}\cite[3]{edwards1995experiences}. Generally this assumption of relative inefficiency is true however in certain circumstances there can be situations where this is actually a practical and viable solution. This project aims to implement a usermode-only networking stack meaning kernel modifications are not plausible and therefore this solution is actually ideal when optimised appropriately reducing the context switching overhead.

% mTCP thread-local storage and multicore
\citeauthor{jeong2014mtcp} show that with the use of multiple receive queues spread across individual CPU cores and fewer locks along with improved buffer management and fewer context switches between kernel and user mode can yield a much improved throughput compared to Linux and other user-mode concepts. Much of the improved performance is thanks to the use of \textit{thread local storage} of socket buffers, TCP buffer pools and other data structures relating to individual threads that are not shared. Greatly reduced usage of locks across threads, reducing \textit{Lock contention}, helps to minimise idle time in both incoming and outgoing packet processing.

% Focussed on userspace implementations as issues found are likely to be similar

\section{TCP Overview}

\section{Implementation Detail}

\section{Implementation Issues}
\subsection{Hijacking the BSD \texttt{socket()} API calls} % chktex 36
% 

\subsection{Frames larger than the interface MTU}
% Caused by 'segmentation offloading'
% Affects TCP checksums on packets greater than MSS/MTU

\subsection{Fighting the Linux TCP/IP stack RST packets}
% Using iptables or libiptc to drop RST on specific ports
%  - Port can't be used by the kernel and could clash?
% Opening the socket to accept the connection
%  - Eventually socket will timeout
%  - Doesn't block any packets from actually getting out
% Kernel module/extension to prevent RST being generated
%  - Could be quicker but defeats isn't truly userspace

\subsection{Efficiently sending and receiving packets through the kernel interface}
\cite{tpacket} % chktex 2
% "it requires one system call to capture each packet, it requires two if you want to get packet's timestamp"
% Use a zero-copy interface like Linux tpacket_v{1,2,3}

\printbibliography % chktex 1
\end{document}
